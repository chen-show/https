<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>雨窗(Three.js)</title>

  <script src="./three.min.js"></script>

  <style>
    *,
    *::before,
    *::after {
      font-family: inherit;
      box-sizing: inherit;
      margin: 0;
      padding: 0;
    }

    html {
      box-sizing: border-box;
      font-family: 'Nunito Sans', sans-serif;
      font-size: 62.5%;
    }

    html body {
      font-size: 1.6rem;
      margin: 0;
      overflow: hidden;
    }

    ul {
      list-style: none;
    }

    a,
    a:link,
    a:visited {
      text-decoration: none;
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  </style>


</head>

<body>
  
  <script src="./script.js"></script>

  <script>
    (window.onload = () => {
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const geometry = new THREE.PlaneGeometry(2, 2);
      const clock = new THREE.Clock();

      const uniforms = {
        u_time: { value: 0.0 },
        u_mouse: { value: { x: 0.0, y: 0.0 } },
        u_resolution: { value: { x: 0.0, y: 0.0 } },
      };

      if (typeof imageURL === 'string') {
        uniforms.u_texture = {
          type: 't',
          value: new THREE.TextureLoader().load(imageURL)
        };
      }

      const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader,
        fragmentShader,
      });

      const plane = new THREE.Mesh(geometry, material);
      scene.add(plane);

      camera.position.z = 1;

      onWindowResize();

      window.addEventListener('resize', onWindowResize, false);
      renderer.domElement.addEventListener('touch', onMouseMove);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      animate();

      function onMouseMove (evt) {
        const { clientX, clientY } = evt.touches ? evt.touches[0] : evt;
        uniforms.u_mouse.value.x = clientX;
        uniforms.u_mouse.value.y = window.innerHeight - clientY;
      }

      function onWindowResize (event) {
        const aspectRatio = window.innerWidth / window.innerHeight;
        let width, height;
        if (aspectRatio >= 1) {
          width = 1;
          height = (window.innerHeight / window.innerWidth) * width;
        } else {
          width = aspectRatio;
          height = 1;
        }
        camera.left = -width;
        camera.right = width;
        camera.top = height;
        camera.bottom = -height;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        if (uniforms.u_resolution) {
          uniforms.u_resolution.value.x = window.innerWidth;
          uniforms.u_resolution.value.y = window.innerHeight;
        }
      }

      function animate () {
        uniforms.u_time.value = clock.getElapsedTime();
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
    })();
  </script>

</body>

</html>